{"version":3,"file":"recurrence.js","sourceRoot":"","sources":["../../../src/backend/types/recurrence.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Type definitions for recurring calendar events\n */\n\n/**\n * Enum for recurrence pattern types\n * Matches the PostgreSQL ENUM type defined in the database\n */\nexport enum RecurrencePatternType {\n  DAILY = 'daily',\n  WEEKLY = 'weekly',\n  MONTHLY = 'monthly',\n  YEARLY = 'yearly',\n  CUSTOM = 'custom'\n}\n\n/**\n * Days of the week, using ISO 8601 numbering (1-7, Monday-Sunday)\n */\nexport enum DayOfWeek {\n  MONDAY = 1,\n  TUESDAY = 2,\n  WEDNESDAY = 3,\n  THURSDAY = 4,\n  FRIDAY = 5,\n  SATURDAY = 6,\n  SUNDAY = 7\n}\n\n/**\n * Type for recurrence end specification\n * Either by count or by date\n */\nexport type RecurrenceEnd = \n  | { type: 'count'; count: number }\n  | { type: 'until'; until: string }  // ISO 8601 date string\n  | { type: 'never' };\n\n/**\n * Interface for recurring event information\n */\nexport interface RecurrenceInfo {\n  /** Whether the event is recurring */\n  isRecurring: boolean;\n  \n  /** The recurrence pattern (daily, weekly, monthly, yearly, custom) */\n  pattern?: RecurrencePatternType;\n  \n  /** The recurrence interval (e.g., every 2 weeks) */\n  interval?: number;\n  \n  /** Days of week for weekly recurrence */\n  daysOfWeek?: DayOfWeek[];\n  \n  /** Day of month for monthly recurrence */\n  dayOfMonth?: number;\n  \n  /** Month for yearly recurrence */\n  month?: number;\n  \n  /** When recurrence ends (by count or date) */\n  end?: RecurrenceEnd;\n  \n  /** Optional iCalendar RRULE for complex patterns */\n  rule?: string;\n  \n  /** Optional timezone for recurrence calculations */\n  timezone?: string;\n}\n\n/**\n * Extended calendar event with recurrence information\n */\nexport interface RecurringCalendarEvent {\n  /** Event ID (UUID) */\n  event_id: string;\n  \n  /** User ID owning the event */\n  user_id: string;\n  \n  /** Event title */\n  title: string;\n  \n  /** Start time (ISO 8601) */\n  start_time: string;\n  \n  /** End time (ISO 8601) */\n  end_time: string;\n  \n  /** Creation timestamp */\n  created_at: string;\n  \n  /** Last update timestamp */\n  updated_at: string;\n  \n  /** Whether it's an all-day event */\n  is_all_day: boolean;\n  \n  /** Optional event description */\n  description?: string | null;\n  \n  /** Optional event location */\n  location?: string | null;\n  \n  /** Optional Google Calendar event ID for sync */\n  google_event_id?: string | null;\n  \n  /** Optional Zoom meeting ID for sync */\n  zoom_meeting_id?: string | null;\n  \n  /** Whether the event is recurring */\n  is_recurring: boolean;\n  \n  /** Recurrence pattern type */\n  recurrence_pattern?: RecurrencePatternType | null;\n  \n  /** Recurrence interval (e.g., every 2 weeks) */\n  recurrence_interval?: number | null;\n  \n  /** Days of week for weekly recurrence */\n  recurrence_day_of_week?: number[] | null;\n  \n  /** Day of month for monthly recurrence */\n  recurrence_day_of_month?: number | null;\n  \n  /** Month for yearly recurrence */\n  recurrence_month?: number | null;\n  \n  /** When recurrence ends (date) */\n  recurrence_end_date?: string | null;\n  \n  /** Number of occurrences */\n  recurrence_count?: number | null;\n  \n  /** iCalendar RRULE for complex patterns */\n  recurrence_rule?: string | null;\n  \n  /** Parent event ID for linked events */\n  parent_event_id?: string | null;\n  \n  /** Whether this is an exception to a recurring pattern */\n  is_exception?: boolean;\n  \n  /** Original date this exception replaces */\n  exception_date?: string | null;\n  \n  /** Series ID for grouping related events */\n  series_id?: string | null;\n  \n  /** Timezone for recurrence calculations */\n  recurrence_timezone?: string | null;\n}\n\n/**\n * Helper type for creating a new recurring event\n */\nexport type NewRecurringCalendarEvent = Omit<\n  RecurringCalendarEvent,\n  'event_id' | 'created_at' | 'updated_at' | 'user_id'\n>;\n\n/**\n * Helper function to convert database model to RecurrenceInfo interface\n */\nexport function extractRecurrenceInfo(event: RecurringCalendarEvent): RecurrenceInfo | null {\n  if (!event.is_recurring) {\n    return null;\n  }\n  \n  // Build the recurrence end specification\n  let end: RecurrenceEnd | undefined;\n  if (event.recurrence_count) {\n    end = { type: 'count', count: event.recurrence_count };\n  } else if (event.recurrence_end_date) {\n    end = { type: 'until', until: event.recurrence_end_date };\n  } else {\n    end = { type: 'never' };\n  }\n  \n  return {\n    isRecurring: true,\n    pattern: event.recurrence_pattern || undefined,\n    interval: event.recurrence_interval || undefined,\n    daysOfWeek: event.recurrence_day_of_week?.map(day => day as DayOfWeek) || undefined,\n    dayOfMonth: event.recurrence_day_of_month || undefined,\n    month: event.recurrence_month || undefined,\n    end,\n    rule: event.recurrence_rule || undefined,\n    timezone: event.recurrence_timezone || undefined\n  };\n}\n\n/**\n * Helper function to convert RecurrenceInfo to database model properties\n */\nexport function createRecurrenceFields(info: RecurrenceInfo): Partial<RecurringCalendarEvent> {\n  const result: Partial<RecurringCalendarEvent> = {\n    is_recurring: info.isRecurring,\n  };\n  \n  if (!info.isRecurring) {\n    return result;\n  }\n  \n  // Add pattern fields if recurring\n  if (info.pattern) {\n    result.recurrence_pattern = info.pattern;\n  }\n  \n  if (info.interval) {\n    result.recurrence_interval = info.interval;\n  }\n  \n  if (info.daysOfWeek && info.daysOfWeek.length > 0) {\n    result.recurrence_day_of_week = info.daysOfWeek;\n  }\n  \n  if (info.dayOfMonth) {\n    result.recurrence_day_of_month = info.dayOfMonth;\n  }\n  \n  if (info.month) {\n    result.recurrence_month = info.month;\n  }\n  \n  // Handle recurrence end\n  if (info.end) {\n    if (info.end.type === 'count') {\n      result.recurrence_count = info.end.count;\n    } else if (info.end.type === 'until') {\n      result.recurrence_end_date = info.end.until;\n    }\n  }\n  \n  if (info.rule) {\n    result.recurrence_rule = info.rule;\n  }\n  \n  if (info.timezone) {\n    result.recurrence_timezone = info.timezone;\n  }\n  \n  return result;\n}\n\n/**\n * Generates a human-readable summary of a recurrence pattern\n */\nexport function formatRecurrenceSummary(info: RecurrenceInfo): string {\n  if (!info.isRecurring || !info.pattern) {\n    return 'Not recurring';\n  }\n  \n  const interval = info.interval && info.interval > 1 ? `every ${info.interval} ` : '';\n  let base = '';\n  \n  switch (info.pattern) {\n    case RecurrencePatternType.DAILY:\n      base = `${interval}day${info.interval && info.interval > 1 ? 's' : ''}`;\n      break;\n    case RecurrencePatternType.WEEKLY:\n      base = `${interval}week${info.interval && info.interval > 1 ? 's' : ''}`;\n      if (info.daysOfWeek && info.daysOfWeek.length > 0) {\n        const days = info.daysOfWeek.map(day => {\n          switch (day) {\n            case DayOfWeek.MONDAY: return 'Mon';\n            case DayOfWeek.TUESDAY: return 'Tue';\n            case DayOfWeek.WEDNESDAY: return 'Wed';\n            case DayOfWeek.THURSDAY: return 'Thu';\n            case DayOfWeek.FRIDAY: return 'Fri';\n            case DayOfWeek.SATURDAY: return 'Sat';\n            case DayOfWeek.SUNDAY: return 'Sun';\n            default: return '';\n          }\n        }).filter(d => d).join(', ');\n        base += ` on ${days}`;\n      }\n      break;\n    case RecurrencePatternType.MONTHLY:\n      base = `${interval}month${info.interval && info.interval > 1 ? 's' : ''}`;\n      if (info.dayOfMonth) {\n        base += ` on day ${info.dayOfMonth}`;\n      }\n      break;\n    case RecurrencePatternType.YEARLY:\n      base = `${interval}year${info.interval && info.interval > 1 ? 's' : ''}`;\n      if (info.month) {\n        const months = [\n          'January', 'February', 'March', 'April', 'May', 'June',\n          'July', 'August', 'September', 'October', 'November', 'December'\n        ];\n        base += ` in ${months[info.month - 1]}`;\n        \n        if (info.dayOfMonth) {\n          base += ` on day ${info.dayOfMonth}`;\n        }\n      }\n      break;\n    case RecurrencePatternType.CUSTOM:\n      base = 'custom pattern';\n      if (info.rule) {\n        base += ` (${info.rule})`;\n      }\n      break;\n  }\n  \n  // Add ending information\n  if (info.end) {\n    if (info.end.type === 'count') {\n      base += `, ${info.end.count} time${info.end.count > 1 ? 's' : ''}`;\n    } else if (info.end.type === 'until') {\n      // Format the end date more nicely\n      const endDate = new Date(info.end.until);\n      base += `, until ${endDate.toLocaleDateString()}`;\n    }\n  }\n  \n  return `Repeats ${base}`;\n}"]}