{"version":3,"file":"contactService.js","sourceRoot":"","sources":["../../../src/backend/services/contactService.ts"],"names":[],"mappings":"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","sourcesContent":["// src/backend/services/contactService.ts\nimport { supabaseAdmin } from './supabaseAdmin';\nimport { isValidUUID } from '../functions/_shared/utils';\nimport { \n  Contact, \n  ContactIdentifier, \n  ContactOperationResult, \n  OperationError \n} from '../types/domain';\nimport {\n  getSafeTimezone,\n  // getTodayInTimezone, // We use calculateNextBirthday which handles timezone internally\n  calculateNextBirthday,\n  // formatDate, // Removed unused import\n  BirthdayCalculation\n} from '../utils/dateTimeUtils';\nimport { getAssistantConfig } from './assistantConfig';\n\n/**\n * Service class for contact-related operations.\n * Centralizes all contact functionality to provide:\n * - Type-safe operations\n * - Consistent error handling\n * - Single point for contact resolution\n */\nexport class ContactService {\n  /**\n   * Find contacts with improperly formatted phone numbers\n   * @param userId The authenticated user ID\n   * @param options Optional parameters for pagination and filtering\n   * @returns Operation result with contacts having improper phone formats and detailed format issues\n   */\n  public async findContactsWithImproperPhoneFormats(\n    userId: string,\n    options: {\n      includeEmpty?: boolean;\n      page?: number;\n      limit?: number;\n    } = {}\n  ): Promise<ContactOperationResult<{\n    contacts: Array<Contact & { formatIssue: string; suggestedFormat?: string }>;\n    pagination: {\n      currentPage: number;\n      totalPages: number;\n      totalContacts: number;\n      limit: number;\n      hasMore: boolean;\n    };\n  }>> {\n    console.log(`[contactService] findContactsWithImproperPhoneFormats called for userId=${userId}, options=`, JSON.stringify(options));\n    \n    try {\n      // Input validation\n      if (!userId) {\n        console.error('[contactService] findContactsWithImproperPhoneFormats failed: Missing user ID');\n        return this.createError('MISSING_USER_ID', 'User ID is required for finding contacts with improper phone formats');\n      }\n      \n      const { \n        includeEmpty = false,\n        page = 1,\n        limit: rawLimit = 20\n      } = options;\n      \n      // Enforce limit boundaries\n      const limit = Math.min(Math.max(1, rawLimit), 50);\n      \n      // First query to get all relevant contacts\n      let query = supabaseAdmin\n        .from('contacts')\n        .select('*')\n        .eq('user_id', userId);\n        \n      if (!includeEmpty) {\n        // Only include contacts with non-empty phone numbers\n        query = query.not('phone', 'is', null)\n                     .neq('phone', '');\n      }\n      \n      const { data: allContacts, error } = await query;\n      \n      if (error) {\n        console.error('[contactService] Error finding contacts with phone numbers:', error);\n        return this.createError(\n          'DATABASE_ERROR',\n          `Error finding contacts: ${error.message}`,\n          { error }\n        );\n      }\n      \n      if (!allContacts || allContacts.length === 0) {\n        return {\n          success: true,\n          data: {\n            contacts: [],\n            pagination: {\n              currentPage: page,\n              totalPages: 0,\n              totalContacts: 0,\n              limit,\n              hasMore: false\n            }\n          }\n        };\n      }\n      \n      // Validate phone numbers in memory with detailed reasons\n      const contactsWithImproperPhones = allContacts\n        .map(contact => {\n          // Skip contacts without phone numbers if we're not including empty\n          if (!contact.phone) {\n            if (includeEmpty) {\n              return { ...contact, formatIssue: 'Missing phone number' };\n            }\n            return null;\n          }\n          \n          const phone = contact.phone.trim();\n          \n          // Check for empty strings after trimming\n          if (phone === '') {\n            if (includeEmpty) {\n              return { ...contact, formatIssue: 'Empty phone number' };\n            }\n            return null;\n          }\n          \n          // Check for non-digit characters (except for allowed formatting characters)\n          // eslint-disable-next-line no-useless-escape\n          if (/[^\\d\\+\\-\\(\\)\\s\\.]/g.test(phone)) {\n            return { \n              ...contact, \n              formatIssue: 'Contains invalid characters',\n              suggestedFormat: this.getSuggestedPhoneFormat(phone)\n            };\n          }\n          \n          // Check for proper formatting with various patterns\n          // International format: +1-234-567-8901\n          const internationalPattern = /^\\+\\d{1,3}[\\s-.]?\\(?\\d{3}\\)?[\\s-.]?\\d{3}[\\s-.]?\\d{4}$/;\n          // US format: (234) 567-8901 or 234-567-8901\n          const usPattern = /^(\\(\\d{3}\\)|\\d{3})[\\s-.]?\\d{3}[\\s-.]?\\d{4}$/;\n          \n          if (internationalPattern.test(phone) || usPattern.test(phone)) {\n            return null; // Properly formatted\n          }\n          \n          // Additional validation checks\n          if (phone.replace(/\\D/g, '').length !== 10 && !phone.startsWith('+')) {\n            return { \n              ...contact, \n              formatIssue: 'Does not have 10 digits (excluding country code)',\n              suggestedFormat: this.getSuggestedPhoneFormat(phone)\n            };\n          }\n          \n          if (phone.startsWith('+') && phone.replace(/\\D/g, '').length !== 11 && phone.replace(/\\D/g, '').length !== 12) {\n            return { \n              ...contact, \n              formatIssue: 'International number with incorrect digit count',\n              suggestedFormat: this.getSuggestedPhoneFormat(phone)\n            };\n          }\n          \n          return { \n            ...contact, \n            formatIssue: 'Improperly formatted',\n            suggestedFormat: this.getSuggestedPhoneFormat(phone)\n          };\n        })\n        .filter((contact): contact is Contact & { formatIssue: string; suggestedFormat?: string } => \n          contact !== null\n        );\n      \n      // Calculate pagination\n      const totalContacts = contactsWithImproperPhones.length;\n      const totalPages = Math.ceil(totalContacts / limit);\n      const validPage = Math.max(1, Math.min(page, totalPages || 1));\n      const startIndex = (validPage - 1) * limit;\n      const endIndex = Math.min(startIndex + limit, totalContacts);\n      \n      // Get the items for this page\n      const pageResults = contactsWithImproperPhones.slice(startIndex, endIndex);\n      \n      console.log(`[contactService] Found ${totalContacts} contacts with improper phone formats, showing page ${validPage}/${totalPages}`);\n      \n      return {\n        success: true,\n        data: {\n          contacts: pageResults,\n          pagination: {\n            currentPage: validPage,\n            totalPages,\n            totalContacts,\n            limit,\n            hasMore: validPage < totalPages\n          }\n        }\n      };\n    } catch (error) {\n      console.error('[contactService] Error finding contacts with improper phone formats:', \n        error instanceof Error ? `${error.name}: ${error.message}\\n${error.stack || 'No stack trace available'}` : error);\n      return this.createError(\n        'UNEXPECTED_ERROR',\n        error instanceof Error ? error.message : 'Unknown error finding contacts with improper phone formats',\n        { error }\n      );\n    }\n  }\n  \n  /**\n   * Suggests a properly formatted phone number based on the input\n   * @private\n   * @param phone The original phone number string\n   * @returns A suggested proper format\n   */\n  private getSuggestedPhoneFormat(phone: string): string {\n    // Extract just the digits\n    const digits = phone.replace(/\\D/g, '');\n    \n    // Not enough digits to format\n    if (digits.length < 10) {\n      return 'Needs at least 10 digits';\n    }\n    \n    // Standard US 10-digit number\n    if (digits.length === 10) {\n      return `(${digits.substring(0, 3)}) ${digits.substring(3, 6)}-${digits.substring(6)}`;\n    }\n    \n    // US number with country code\n    if (digits.length === 11 && digits.startsWith('1')) {\n      return `+1 (${digits.substring(1, 4)}) ${digits.substring(4, 7)}-${digits.substring(7)}`;\n    }\n    \n    // International number (simple suggestion)\n    if (digits.length > 10) {\n      const countryCodeLength = digits.length - 10;\n      return `+${digits.substring(0, countryCodeLength)} (${digits.substring(countryCodeLength, countryCodeLength + 3)}) ${digits.substring(countryCodeLength + 3, countryCodeLength + 6)}-${digits.substring(countryCodeLength + 6)}`;\n    }\n    \n    return 'Cannot determine proper format';\n  }\n\n  /**\n   * Find potential duplicate contacts for a user\n   * @param userId The authenticated user ID\n   * @param options Optional parameters for duplicate detection\n   * @returns Operation result with duplicate contacts or error\n   */\n  public async findDuplicateContacts(\n    userId: string,\n    options: {\n      threshold?: number; // Similarity threshold (0-1), default 0.6\n      includeArchived?: boolean; // Whether to include archived contacts, default false\n      page?: number; // Page number for pagination, default 1\n      limit?: number; // Results per page, default 10, max 25\n      sortBy?: 'confidence' | 'name' | 'email'; // Sort field, default 'confidence'\n    } = {}\n  ): Promise<ContactOperationResult<{\n    groups: Array<{\n      contact: Contact;\n      duplicates: Array<{\n        contact: Contact;\n        confidence: number;\n        matchReason: string[];\n      }>;\n    }>;\n    pagination: {\n      currentPage: number;\n      totalPages: number;\n      totalGroups: number;\n      limit: number;\n      hasMore: boolean;\n    };\n  }>> {\n    console.log(`[contactService] findDuplicateContacts called for userId=${userId}, options=`, JSON.stringify(options));\n    try {\n      // Input validation\n      if (!userId) {\n        console.error('[contactService] findDuplicateContacts failed: Missing user ID');\n        return this.createError('MISSING_USER_ID', 'User ID is required for finding duplicate contacts');\n      }\n      \n      const { \n        threshold = 0.6, \n        includeArchived = false,\n        page = 1,\n        limit: rawLimit = 10,\n        sortBy = 'confidence'\n      } = options;\n\n      // Enforce limit boundaries (max 25 items per page to prevent timeouts)\n      const limit = Math.min(Math.max(1, rawLimit), 25);\n      \n      console.log(`[contactService] Using threshold=${threshold}, includeArchived=${includeArchived}, page=${page}, limit=${limit}, sortBy=${sortBy}`);\n      \n      // First, check if we have at least 2 contacts (minimum needed for duplicates)\n      const { count, error: countError } = await supabaseAdmin\n        .from('contacts')\n        .select('*', { count: 'exact', head: true })\n        .eq('user_id', userId)\n        .is('is_archived', includeArchived ? null : false);\n      \n      if (countError) {\n        console.error('[contactService] Error counting contacts:', countError);\n        // Continue with fallback approach instead of failing\n        console.log('[contactService] Falling back to direct fetch method due to count error');\n      }\n      \n      if (!count || count < 2) {\n        console.log(`[contactService] Insufficient contacts for duplicate detection (found ${count}, need at least 2)`);\n        return {\n          success: true,\n          data: {\n            groups: [],\n            pagination: {\n              currentPage: page,\n              totalPages: 0,\n              totalGroups: 0,\n              limit,\n              hasMore: false\n            }\n          }\n        };\n      }\n      \n      console.log(`[contactService] Found ${count} eligible contacts for user, proceeding with duplicate detection`);\n\n      // Use the database function to find potential duplicates\n      // We'll gather all contacts and their potential duplicates from the database function\n      const duplicateContactsMap = new Map<string, {\n        contact: Contact;\n        duplicates: Array<{\n          contact: Contact;\n          confidence: number;\n          matchReason: string[];\n        }>;\n      }>();\n      \n      console.log(`[contactService] Executing SQL to find duplicate contacts using database function`);\n\n      // Get all contacts first to have their full details\n      const { data: contacts, error: contactsError } = await supabaseAdmin\n        .from('contacts')\n        .select('*')\n        .eq('user_id', userId)\n        .is('is_archived', includeArchived ? null : false);\n      \n      if (contactsError) {\n        console.error('[contactService] Error fetching contacts:', contactsError);\n        return this.createError(\n          'DATABASE_ERROR',\n          `Error fetching contacts: ${contactsError.message}`,\n          { error: contactsError }\n        );\n      }\n      \n      if (!contacts || contacts.length === 0) {\n        // Should not happen since we already checked the count, but handle it anyway\n        console.log('[contactService] No contacts found for user despite positive count');\n        return {\n          success: true,\n          data: {\n            groups: [],\n            pagination: {\n              currentPage: page,\n              totalPages: 0,\n              totalGroups: 0,\n              limit,\n              hasMore: false\n            }\n          }\n        };\n      }\n      \n      console.log(`[contactService] Found ${contacts.length} contacts for user`);\n      \n      // Create a map of contacts by ID for quick lookup\n      const contactsById = new Map<string, Contact>();\n      for (const contact of contacts) {\n        contactsById.set(contact.contact_id, contact);\n      }\n\n      // Calculate pagination offset for database function\n      const offset = (page - 1) * limit;\n     \n      // Call the optimized database function for finding duplicates\n      console.log(`[contactService] Calling find_all_duplicate_contacts with userId=${userId}, includeArchived=${includeArchived}, limit=${limit}, offset=${offset}`);\n      \n      const { data: potentialDuplicates, error: duplicatesError } = await supabaseAdmin\n        .rpc('find_all_duplicate_contacts', { \n          p_user_id: userId,\n          p_include_archived: includeArchived,\n          p_limit: limit * 5, // Fetch more to ensure we have enough for grouping\n          p_offset: offset\n        });\n        \n      if (duplicatesError) {\n        console.error('[contactService] Error executing find_all_duplicate_contacts function:', duplicatesError);\n        return this.createError(\n          'DATABASE_ERROR',\n          `Error finding duplicate contacts: ${duplicatesError.message}`,\n          { error: duplicatesError }\n        );\n      }\n      \n      console.log(`[contactService] Database function returned ${potentialDuplicates?.length || 0} potential duplicate matches`);\n      \n      if (!potentialDuplicates || potentialDuplicates.length === 0) {\n        // No duplicates found\n        console.log('[contactService] No duplicates found by database function');\n        return {\n          success: true,\n          data: {\n            groups: [],\n            pagination: {\n              currentPage: page,\n              totalPages: 0,\n              totalGroups: 0,\n              limit,\n              hasMore: false\n            }\n          }\n        };\n      }\n      \n      // Define the interface for duplicate entries from the new database function\n      interface DuplicateEntry {\n        source_contact_id: string;\n        duplicate_contact_id: string;\n        confidence: number;\n        match_reasons: string[];\n      }\n      \n      // Process the results from the database function\n      // The function returns pairs of duplicate contacts with source_contact_id, duplicate_contact_id, confidence, and match_reasons\n      if (potentialDuplicates && potentialDuplicates.length > 0) {\n        console.log(`[contactService] Processing ${potentialDuplicates.length} potential duplicate matches`);\n        \n        // Group the duplicates by source contact\n        for (const duplicate of potentialDuplicates as DuplicateEntry[]) {\n          // Skip if we can't find either contact\n          if (!duplicate.source_contact_id || !duplicate.duplicate_contact_id || \n              !contactsById.has(duplicate.source_contact_id) || \n              !contactsById.has(duplicate.duplicate_contact_id)) {\n            continue;\n          }\n          \n          // Get the source contact\n          const sourceContact = contactsById.get(duplicate.source_contact_id);\n          if (!sourceContact) {\n            continue; // Skip if we can't find the source contact\n          }\n          \n          // Get the duplicate contact\n          const duplicateContact = contactsById.get(duplicate.duplicate_contact_id);\n          if (!duplicateContact) {\n            continue; // Skip if we can't find the duplicate contact\n          }\n          \n          // Get existing entry or create a new one for the source contact\n          let contactEntry = duplicateContactsMap.get(duplicate.source_contact_id);\n          if (!contactEntry) {\n            contactEntry = {\n              contact: sourceContact,\n              duplicates: []\n            };\n            duplicateContactsMap.set(duplicate.source_contact_id, contactEntry);\n          }\n          \n          // Add the duplicate to the entry with the confidence and match reasons directly from the database\n          contactEntry.duplicates.push({\n            contact: duplicateContact,\n            confidence: duplicate.confidence,\n            matchReason: duplicate.match_reasons || ['Match found']\n          });\n        }\n      }\n      \n      // Convert the map to an array for processing\n      const allResults = Array.from(duplicateContactsMap.values());\n      console.log(`[contactService] Processed ${allResults.length} duplicate groups`);\n      \n      // Sort the duplicates within each group by confidence\n      for (const result of allResults) {\n        result.duplicates.sort((a, b) => b.confidence - a.confidence);\n      }\n      \n      // Sort the entire result set based on the requested sort parameter\n      const sortedResults = [...allResults].sort((a, b) => {\n        let aName: string, bName: string;\n        let aEmail: string, bEmail: string;\n        let aMaxConfidence: number, bMaxConfidence: number;\n        \n        switch (sortBy) {\n          case 'name':\n            aName = `${a.contact.first_name || ''} ${a.contact.last_name || ''}`.trim().toLowerCase();\n            bName = `${b.contact.first_name || ''} ${b.contact.last_name || ''}`.trim().toLowerCase();\n            return aName.localeCompare(bName);\n          \n          case 'email':\n            aEmail = (a.contact.email || '').toLowerCase();\n            bEmail = (b.contact.email || '').toLowerCase();\n            return aEmail.localeCompare(bEmail);\n          \n          case 'confidence':\n          default:\n            // For confidence sorting, use the highest confidence duplicate\n            aMaxConfidence = a.duplicates.length > 0 ? a.duplicates[0].confidence : 0;\n            bMaxConfidence = b.duplicates.length > 0 ? b.duplicates[0].confidence : 0;\n            return bMaxConfidence - aMaxConfidence; // Higher confidence first\n        }\n      });\n\n      // Calculate pagination values\n      const totalGroups = sortedResults.length;\n      const totalPages = Math.ceil(totalGroups / limit);\n      const validPage = Math.max(1, Math.min(page, totalPages || 1));\n      const startIndex = (validPage - 1) * limit;\n      const endIndex = Math.min(startIndex + limit, totalGroups);\n      \n      // Get the items for this page\n      const pageResults = sortedResults.slice(startIndex, endIndex);\n\n      console.log(`[contactService] Duplicate detection complete. Found ${totalGroups} groups with pagination: page ${validPage}/${totalPages}, showing ${pageResults.length} items`);\n      \n      return {\n        success: true,\n        data: {\n          groups: pageResults,\n          pagination: {\n            currentPage: validPage,\n            totalPages,\n            totalGroups,\n            limit,\n            hasMore: validPage < totalPages\n          }\n        }\n      };\n    } catch (error) {\n      console.error('[contactService] Error finding duplicate contacts:', \n        error instanceof Error ? `${error.name}: ${error.message}\\n${error.stack || 'No stack trace available'}` : error);\n      return this.createError(\n        'UNEXPECTED_ERROR',\n        error instanceof Error ? error.message : 'Unknown error during duplicate contact detection',\n        { error }\n      );\n    }\n  }\n\n  /**\n   * Finds contacts based on birthday criteria.\n   * @param userId The authenticated user ID.\n   * @param birthdayArgs Arguments for the birthday query.\n   * @param localTimeZone The user's local timezone string (e.g., 'America/New_York').\n   * @returns Operation result with contacts matching birthday criteria.\n   */\n  public async findContactsByBirthday(\n    userId: string,\n    birthdayArgs: {\n      birthday_query_type: 'upcoming' | 'on_date' | 'in_month' | 'in_range' | null;\n      date_range_start?: string | null; // YYYY-MM-DD\n      date_range_end?: string | null; // YYYY-MM-DD\n      month?: number | null; // 1-12\n    },\n    localTimeZone?: string | null\n  ): Promise<ContactOperationResult<Array<Contact | (Contact & BirthdayCalculation)>>> {\n    const reqId = `contactService-findByBirthday-${Date.now()}`;\n    console.log(`[${reqId}][contactService] findContactsByBirthday called for userId=${userId}, args=`, birthdayArgs, `tz=${localTimeZone || 'N/A'}`);\n\n    if (!userId) {\n      return this.createError('MISSING_USER_ID', 'User ID is required for birthday queries.');\n    }\n    if (!birthdayArgs || !birthdayArgs.birthday_query_type) {\n      return this.createError('INVALID_ARGUMENTS', 'birthday_query_type is required.');\n    }\n\n    // Interface for contacts that have had upcoming birthday info calculated\n    // This needs to be accessible if returned, so it's part of the Promise return type.\n    // Let's call it ContactWithCalculatedBirthdayInfo for clarity if used outside.\n    type ContactWithCalculatedBirthdayInfo = Contact & { \n      birthDate: Date; // Original birthdate (YYYY-MM-DD stored as Date obj at midnight UTC)\n      diffDays: number; // Days until next birthday from user's perspective\n      nextBirthday: Date; // Date of the next birthday in user's local timezone (at midnight)\n      birthDateInLocalTzAsDate: Date; // Parsed birthday as a Date object representing midnight in user's local timezone\n    };\n\n    try {\n      // Get a safely validated timezone string\n      const validTimeZone = getSafeTimezone(localTimeZone, `[${reqId}][contactService]`);\n      \n      // We pass validTimeZone to other utility functions that need it instead of using todayInLocalTz directly\n      \n      console.log(`[${reqId}][contactService] Processing birthday query type '${birthdayArgs.birthday_query_type}' in timezone ${validTimeZone}`);\n\n      // Build the database query\n      let query = supabaseAdmin.from('contacts')\n        .select('*') // Select all fields as per the Contact type from domain\n        .eq('user_id', userId)\n        .not('birthday', 'is', null);\n\n      switch (birthdayArgs.birthday_query_type) {\n        case 'upcoming':\n          // JS filtering for 'upcoming' will be done post-fetch\n          // The query itself doesn't need specific date filters here for upcoming, it fetches all with birthdays.\n          break;\n        case 'on_date':\n          if (birthdayArgs.date_range_start) {\n            // Assuming date_range_start is YYYY-MM-DD. We need to find birthdays on this MM-DD in any year.\n            const [, month, day] = birthdayArgs.date_range_start.split('-').map(Number); // Ignore year part\n            // Supabase stores dates as 'YYYY-MM-DD'. The `like` query is good for MM-DD matching across years.\n            query = query.filter('birthday', 'like', `%-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`);\n          } else {\n            return this.createError('INVALID_ARGUMENTS', \"date_range_start is required for 'on_date' birthday query.\");\n          }\n          break;\n        case 'in_month':\n          if (birthdayArgs.month) {\n            query = query.filter('birthday', 'like', `%-${String(birthdayArgs.month).padStart(2, '0')}-%`);\n          } else {\n            return this.createError('INVALID_ARGUMENTS', \"month is required for 'in_month' birthday query.\");\n          }\n          break;\n        case 'in_range':\n          if (birthdayArgs.date_range_start && birthdayArgs.date_range_end) {\n            query = query.gte('birthday', birthdayArgs.date_range_start).lte('birthday', birthdayArgs.date_range_end);\n          } else {\n            return this.createError('INVALID_ARGUMENTS', \"date_range_start and date_range_end are required for 'in_range' birthday query.\");\n          }\n          break;\n        default:\n          return this.createError('INVALID_ARGUMENTS', `Unsupported birthday_query_type: ${birthdayArgs.birthday_query_type}`);\n      }\n\n      // Corrected usage for typed Supabase results\n      const { data, error } = await query;\n      const contacts: Contact[] | null = data as Contact[] | null;\n\n      if (error) {\n        console.error(`[${reqId}][contactService] Supabase error fetching birthdays:`, error);\n        return this.createError('DATABASE_ERROR', `Error fetching birthdays: ${error.message}`, { error });\n      }\n\n      if (!contacts) {\n        return { success: true, data: [] };\n      }\n\n      let processedContacts: Array<Contact | ContactWithCalculatedBirthdayInfo> = contacts;\n\n      if (birthdayArgs.birthday_query_type === 'upcoming') {\n        // Calculate upcoming days - from explicit range or use configured default (90 days)\n        const config = getAssistantConfig();\n        const upcomingDays = (birthdayArgs.date_range_start && birthdayArgs.date_range_end && \n                            birthdayArgs.date_range_start !== birthdayArgs.date_range_end) ? \n                             (new Date(birthdayArgs.date_range_end).getTime() - new Date(birthdayArgs.date_range_start).getTime()) / (1000 * 3600 * 24) :\n                             config.upcomingBirthdayDays;\n        \n        console.log(`[${reqId}][contactService] Using upcoming days window: ${upcomingDays} (default config: ${config.upcomingBirthdayDays})`);\n        \n        // Process contacts using the utility functions\n        processedContacts = contacts\n          .map((c: Contact) => {\n            if (!c.birthday) return null;\n            \n            // Calculate next birthday for this contact\n            const birthdayCalc = calculateNextBirthday(c.birthday, validTimeZone, reqId);\n            if (!birthdayCalc) return null;\n            \n            // Combine contact with birthday calculation\n            return { ...c, ...birthdayCalc };\n          })\n          .filter((c): c is Contact & BirthdayCalculation => c !== null)\n          // Filter contacts whose birthday is within the upcoming days period\n          .filter(c => c.diffDays >= 0 && c.diffDays <= upcomingDays)\n          // Sort by days until birthday (soonest first)\n          .sort((a, b) => a.diffDays - b.diffDays);\n        \n        console.log(`[${reqId}][contactService] Found ${processedContacts.length} contacts with upcoming birthdays in the next ${upcomingDays} days`);\n      } else if (contacts.length > 0) {\n        // For other queries, sort contacts by month/day of birthday\n        processedContacts = [...contacts]\n          // Filter out contacts without birthdays (should be handled by DB query, but just to be safe)\n          .filter(c => !!c.birthday)\n          // Sort contacts by month and day\n          .sort((a, b) => {\n            if (!a.birthday || !b.birthday) return 0;\n            \n            try {\n              // Calculate birthday data for both contacts\n              const birthdayCalcA = calculateNextBirthday(a.birthday, validTimeZone, reqId);\n              const birthdayCalcB = calculateNextBirthday(b.birthday, validTimeZone, reqId);\n              \n              // If we couldn't calculate either birthday, use string comparison as fallback\n              if (!birthdayCalcA || !birthdayCalcB) {  \n                return (a.birthday || '').localeCompare(b.birthday || '');\n              }\n              \n              // Compare birthdays by month, then by day\n              const monthA = birthdayCalcA.birthDate.getMonth();\n              const dayA = birthdayCalcA.birthDate.getDate();\n              const monthB = birthdayCalcB.birthDate.getMonth();\n              const dayB = birthdayCalcB.birthDate.getDate();\n              \n              if (monthA === monthB) {\n                return dayA - dayB;\n              }\n              return monthA - monthB;\n            } catch (sortError) {\n              // Fallback to simple string comparison if there's an error\n              console.warn(`[${reqId}][contactService] Error sorting dates ${a.birthday} and ${b.birthday}:`, \n                sortError instanceof Error ? sortError.message : String(sortError));\n              return (a.birthday || '').localeCompare(b.birthday || '');\n            }\n          });\n            \n        console.log(`[${reqId}][contactService] Found ${processedContacts.length} contacts with birthday data`);\n      }\n      return { success: true, data: processedContacts };\n\n    } catch (e) {\n      const errorMsg = e instanceof Error ? e.message : String(e);\n      console.error(`[${reqId}][contactService] Error processing birthday query: ${errorMsg}`, e);\n      return this.createError('SERVICE_ERROR', `Failed to process birthday query: ${errorMsg}`, { \n        error: e,\n        timezone: localTimeZone,\n        queryType: birthdayArgs.birthday_query_type,\n        birthdayArgs: JSON.stringify(birthdayArgs),\n        originalStackTrace: e instanceof Error ? e.stack : undefined\n      });\n    }\n  }\n\n  /**\n   * Calculate string similarity using Levenshtein distance\n   * @param str1 First string\n   * @param str2 Second string\n   * @returns Similarity score between 0 and 1\n   */\n  private calculateStringSimilarity(str1: string, str2: string): number {\n    if (str1 === str2) return 1.0;\n    if (str1.length === 0 || str2.length === 0) return 0.0;\n    \n    const len1 = str1.length;\n    const len2 = str2.length;\n    \n    // Create distance matrix\n    const distanceMatrix: number[][] = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\n    \n    // Initialize first row and column\n    for (let i = 0; i <= len1; i++) {\n      distanceMatrix[i][0] = i;\n    }\n    for (let j = 0; j <= len2; j++) {\n      distanceMatrix[0][j] = j;\n    }\n    \n    // Fill in the rest of the matrix\n    for (let i = 1; i <= len1; i++) {\n      for (let j = 1; j <= len2; j++) {\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        distanceMatrix[i][j] = Math.min(\n          distanceMatrix[i - 1][j] + 1, // deletion\n          distanceMatrix[i][j - 1] + 1, // insertion\n          distanceMatrix[i - 1][j - 1] + cost // substitution\n        );\n      }\n    }\n    \n    // Levenshtein distance\n    const distance = distanceMatrix[len1][len2];\n    \n    // Convert to similarity score (0-1)\n    const maxLength = Math.max(len1, len2);\n    return maxLength === 0 ? 1.0 : 1.0 - distance / maxLength;\n  }\n\n  /**\n   * Normalize phone number for comparison\n   * @param phone Phone number to normalize\n   * @returns Normalized phone number with only digits\n   */\n  private normalizePhone(phone: string): string {\n    // Remove all non-digit characters\n    return phone.replace(/\\D/g, '');\n  }\n\n  /**\n   * Resolves a contact using different identifier types\n   * @param userId The authenticated user ID\n   * @param identifier Type-safe contact identifier (by ID, name, or email)\n   * @returns Operation result with contact data or error\n   */\n  public async resolveContact(\n    userId: string,\n    identifier: ContactIdentifier\n  ): Promise<ContactOperationResult<Contact>> {\n    try {\n      // Input validation\n      if (!userId) {\n        return this.createError('MISSING_USER_ID', 'User ID is required');\n      }\n\n      // Resolve based on identifier type\n      if (identifier.type === 'id') {\n        // Must be a valid UUID\n        if (!isValidUUID(identifier.contact_id)) {\n          return this.createError('INVALID_ID', `Contact ID is not a valid UUID: ${identifier.contact_id}`);\n        }\n        return await this.getContactById(userId, identifier.contact_id);\n      } \n      else if (identifier.type === 'name') {\n        // Name cannot be empty\n        if (!identifier.name.trim()) {\n          return this.createError('INVALID_NAME', 'Contact name cannot be empty');\n        }\n        return await this.findContactByName(userId, identifier.name);\n      } \n      else if (identifier.type === 'email') {\n        // Email should be provided\n        if (!identifier.email.trim()) {\n          return this.createError('INVALID_EMAIL', 'Contact email cannot be empty');\n        }\n        return await this.findContactByEmail(userId, identifier.email);\n      }\n      \n      // This should be unreachable with TypeScript's discriminated unions\n      return this.createError(\n        'INVALID_IDENTIFIER_TYPE',\n        'Invalid contact identifier type'\n      );\n    } catch (error) {\n      // Handle unexpected errors\n      return this.createError(\n        'RESOLUTION_ERROR',\n        error instanceof Error ? error.message : 'Unknown error during contact resolution',\n        { error }\n      );\n    }\n  }\n\n  /**\n   * Deletes a contact with proper error handling\n   * @param userId The authenticated user ID\n   * @param identifier Type-safe contact identifier\n   * @returns Operation result with deleted contact info or error\n   */\n  public async deleteContact(\n    userId: string, \n    identifier: ContactIdentifier\n  ): Promise<ContactOperationResult<{ contact_id: string; name: string }>> {\n    try {\n      // First resolve the contact to ensure it exists and belongs to user\n      const resolution = await this.resolveContact(userId, identifier);\n      \n      if (!resolution.success || !resolution.data) {\n        return {\n          success: false,\n          error: resolution.error || {\n            code: 'CONTACT_NOT_FOUND',\n            message: 'Contact could not be resolved for deletion'\n          }\n        };\n      }\n      \n      const contact = resolution.data;\n      const contactName = `${contact.first_name || ''} ${contact.last_name || ''}`.trim() || 'Unknown';\n      \n      // Perform the delete operation\n      const { error } = await supabaseAdmin\n        .from('contacts')\n        .delete()\n        .eq('contact_id', contact.contact_id)\n        .eq('user_id', userId);\n\n      if (error) {\n        return this.createError(\n          'DELETE_FAILED',\n          `Failed to delete contact: ${error.message}`,\n          { error }\n        );\n      }\n\n      // Return success with the contact info\n      return {\n        success: true,\n        data: {\n          contact_id: contact.contact_id,\n          name: contactName\n        }\n      };\n    } catch (error) {\n      return this.createError(\n        'UNEXPECTED_ERROR',\n        error instanceof Error ? error.message : 'Unknown error during contact deletion',\n        { error }\n      );\n    }\n  }\n\n  /**\n   * Helper method to get a contact by ID\n   * @private\n   */\n  private async getContactById(\n    userId: string,\n    contactId: string\n  ): Promise<ContactOperationResult<Contact>> {\n    const { data, error } = await supabaseAdmin\n      .from('contacts')\n      .select('*')\n      .eq('contact_id', contactId)\n      .eq('user_id', userId)\n      .single();\n\n    if (error) {\n      return this.createError(\n        error.code === 'PGRST116' ? 'CONTACT_NOT_FOUND' : 'DATABASE_ERROR',\n        error.code === 'PGRST116' \n          ? `Contact with ID ${contactId} not found` \n          : `Database error: ${error.message}`,\n        { error }\n      );\n    }\n\n    return {\n      success: true,\n      data: data as Contact\n    };\n  }\n\n  /**\n   * Helper method to find a contact by name\n   * @private\n   */\n  private async findContactByName(\n    userId: string,\n    name: string\n  ): Promise<ContactOperationResult<Contact>> {\n    // Extract first name for better matching\n    const firstName = name.split(' ')[0];\n    \n    const { data, error } = await supabaseAdmin\n      .from('contacts')\n      .select('*')\n      .eq('user_id', userId)\n      .ilike('first_name', `%${firstName}%`)\n      .order('created_at', { ascending: false })\n      .limit(5);\n\n    if (error) {\n      return this.createError(\n        'DATABASE_ERROR',\n        `Error searching for contact by name: ${error.message}`,\n        { error }\n      );\n    }\n\n    if (!data || data.length === 0) {\n      return this.createError(\n        'CONTACT_NOT_FOUND',\n        `No contacts found matching name \"${name}\"`\n      );\n    }\n\n    // If multiple contacts match, use the most recently created one\n    // This is a simple heuristic - in a real system, you might want\n    // to implement more sophisticated matching or ask for clarification\n    return {\n      success: true,\n      data: data[0] as Contact\n    };\n  }\n\n  /**\n   * Helper method to find a contact by email\n   * @private\n   */\n  private async findContactByEmail(\n    userId: string,\n    email: string\n  ): Promise<ContactOperationResult<Contact>> {\n    const { data, error } = await supabaseAdmin\n      .from('contacts')\n      .select('*')\n      .eq('user_id', userId)\n      .ilike('email', email)\n      .single();\n\n    if (error) {\n      return this.createError(\n        error.code === 'PGRST116' ? 'CONTACT_NOT_FOUND' : 'DATABASE_ERROR',\n        error.code === 'PGRST116' \n          ? `Contact with email ${email} not found` \n          : `Database error: ${error.message}`,\n        { error }\n      );\n    }\n\n    return {\n      success: true,\n      data: data as Contact\n    };\n  }\n\n  /**\n   * Helper to create error results with a consistent structure\n   * @private\n   */\n  private createError(\n    code: string,\n    message: string,\n    details?: unknown\n  ): ContactOperationResult<never> {\n    const error: OperationError = {\n      code,\n      message\n    };\n    \n    if (details !== undefined) {\n      error.details = details;\n    }\n    \n    return {\n      success: false,\n      error\n    };\n  }\n}\n\n// Export a singleton instance\nexport const contactService = new ContactService();"]}