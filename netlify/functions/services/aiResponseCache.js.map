{"version":3,"file":"aiResponseCache.js","sourceRoot":"","sources":["../../../src/backend/services/aiResponseCache.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAEH,sDAAmD;AAQnD,MAAM,eAAe;IAArB;QACU,UAAK,GAA4B,IAAI,GAAG,EAAE,CAAC;QAClC,gBAAW,GAAG,IAAA,yBAAW,EAAC,WAAW,CAAC,CAAC,CAAC,+CAA+C;IAwD1G,CAAC;IAtDC;;OAEG;IACK,WAAW,CAAC,UAAkB,EAAE,QAAqC;QAC3E,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACpE,OAAO,UAAU,UAAU,IAAI,UAAU,EAAE,CAAC;IAC9C,CAAC;IAED;;OAEG;IACH,GAAG,CAAC,UAAkB,EAAE,QAAqC;QAC3D,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QACnD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAElC,IAAI,CAAC,KAAK;YAAE,OAAO,IAAI,CAAC;QAExB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,IAAI,GAAG,GAAG,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;YACtC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACvB,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,KAAK,CAAC,QAAQ,CAAC;IACxB,CAAC;IAED;;OAEG;IACH,GAAG,CAAC,UAAkB,EAAE,QAAqC,EAAE,QAAgB,EAAE,GAAY;QAC3F,MAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QACnD,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE;YAClB,QAAQ;YACR,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;YACrB,GAAG,EAAE,GAAG,IAAI,IAAI,CAAC,WAAW;SAC7B,CAAC,CAAC;QAEH,oCAAoC;QACpC,IAAI,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,CAAC;YACxB,IAAI,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;IACH,CAAC;IAED;;OAEG;IACK,OAAO;QACb,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC;YAChD,IAAI,GAAG,GAAG,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;gBACtC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YACzB,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAEY,QAAA,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC","sourcesContent":["/**\n * AI Response Cache Service\n * Caches formatted AI responses to improve performance\n */\n\nimport { getCacheTTL } from '../utils/cacheConfig';\n\ninterface CacheEntry {\n  response: string;\n  timestamp: number;\n  ttl: number;\n}\n\nclass AIResponseCache {\n  private cache: Map<string, CacheEntry> = new Map();\n  private readonly DEFAULT_TTL = getCacheTTL('assistant'); // Use centralized config for assistant updates\n  \n  /**\n   * Generate a cache key for contact search results\n   */\n  private generateKey(searchTerm: string, contacts: Array<{contact_id: string}>): string {\n    const contactIds = contacts.map(c => c.contact_id).sort().join(',');\n    return `search:${searchTerm}:${contactIds}`;\n  }\n  \n  /**\n   * Get cached response if available and not expired\n   */\n  get(searchTerm: string, contacts: Array<{contact_id: string}>): string | null {\n    const key = this.generateKey(searchTerm, contacts);\n    const entry = this.cache.get(key);\n    \n    if (!entry) return null;\n    \n    const now = Date.now();\n    if (now - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return entry.response;\n  }\n  \n  /**\n   * Cache a formatted response\n   */\n  set(searchTerm: string, contacts: Array<{contact_id: string}>, response: string, ttl?: number): void {\n    const key = this.generateKey(searchTerm, contacts);\n    this.cache.set(key, {\n      response,\n      timestamp: Date.now(),\n      ttl: ttl || this.DEFAULT_TTL\n    });\n    \n    // Clean up old entries periodically\n    if (Math.random() < 0.1) {\n      this.cleanup();\n    }\n  }\n  \n  /**\n   * Remove expired entries\n   */\n  private cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\nexport const aiResponseCache = new AIResponseCache();"]}