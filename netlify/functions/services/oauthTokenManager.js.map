{"version":3,"file":"oauthTokenManager.js","sourceRoot":"","sources":["../../../src/backend/services/oauthTokenManager.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * OAuth Token Manager\n * \n * A comprehensive service for managing OAuth tokens across multiple providers.\n * This implements a repository pattern for token storage, retrieval and refresh.\n * \n * Key features:\n * - Provider-agnostic token management\n * - Transaction support for database operations\n * - Comprehensive error handling\n * - Intelligent token caching and refresh\n * - Self-healing database consistency\n */\n\nimport { supabaseAdmin } from './supabaseAdmin';\nimport { google } from 'googleapis';\nimport { \n  OAuthError,\n  TokenNotFoundError,\n  TokenExpiredError,\n  TokenRefreshError,\n  InsufficientScopeError,\n  OAuthDatabaseError\n} from './errors/oauthErrors';\nimport { oauthConfigService } from './oauthConfigService';\n\n// Types for token management\nexport interface OAuthTokenSet {\n  access_token: string;\n  refresh_token?: string | null;\n  expires_at?: string | null;\n  scope?: string | null;\n  id_token?: string | null;\n  token_type?: string | null;\n}\n\nexport interface OAuthTokenRecord {\n  id: string;\n  user_id: string;\n  provider: string;\n  provider_user_id?: string | null;\n  access_token: string;\n  refresh_token?: string | null;\n  token_type?: string | null;\n  expires_at?: string | null;\n  scope?: string | null;\n  id_token?: string | null;\n  created_at?: string;\n  updated_at?: string;\n}\n\nexport interface TokenRefreshResult {\n  accessToken: string;\n  refreshToken: string | null;\n  expiresAt: string | null;\n  scope: string | null;\n}\n\ninterface TokenResponse {\n  token: OAuthTokenRecord;\n  refreshed: boolean;\n}\n\nexport type OAuthProvider = 'google' | 'microsoft' | 'apple';\nexport type OAuthFeature = 'contacts' | 'calendar' | 'calendar_readonly';\n\n/**\n * Main token manager service\n */\nexport class OAuthTokenManager {\n  // Cache to reduce database lookups\n  private tokenCache: Map<string, { token: OAuthTokenRecord; timestamp: number }> = new Map();\n  private readonly CACHE_TTL_MS = 60000; // 1 minute\n  private readonly EXPIRY_BUFFER_MS = 300000; // 5 minutes buffer for token refresh\n  \n  constructor() {\n    // Initialize service\n    console.log('[OAuthTokenManager] Service initialized');\n  }\n  \n  /**\n   * Gets a valid token for a specific feature requirement\n   * Handles token refresh if needed and verification of required scopes\n   */\n  public async getTokenForFeature(\n    userId: string, \n    provider: OAuthProvider, \n    feature: OAuthFeature\n  ): Promise<string> {\n    // Get the required scopes for this feature\n    const requiredScopes = oauthConfigService.getRequiredScopesForFeature(feature);\n    \n    // Get a valid token (will be refreshed if needed)\n    const tokenResponse = await this.getValidToken(userId, provider);\n    \n    // Verify the token has the required scopes\n    if (tokenResponse.token.scope) {\n      const hasScopes = oauthConfigService.hasRequiredScopes(\n        tokenResponse.token.scope, \n        requiredScopes\n      );\n      \n      if (!hasScopes) {\n        // Get the current scopes as an array\n        const currentScopeArray = tokenResponse.token.scope.split(' ');\n        \n        throw new InsufficientScopeError(\n          userId,\n          provider,\n          requiredScopes,\n          currentScopeArray\n        );\n      }\n    } else {\n      // If no scope information, we can't verify, so throw an error\n      throw new InsufficientScopeError(\n        userId,\n        provider,\n        requiredScopes,\n        []\n      );\n    }\n    \n    return tokenResponse.token.access_token;\n  }\n  \n  /**\n   * Retrieves a valid token, refreshing if necessary\n   */\n  public async getValidToken(\n    userId: string, \n    provider: OAuthProvider\n  ): Promise<TokenResponse> {\n    try {\n      // Try to get the token from cache first\n      const cacheKey = `${userId}:${provider}`;\n      const cachedToken = this.tokenCache.get(cacheKey);\n      \n      // If we have a cached token that's still fresh\n      if (cachedToken && (Date.now() - cachedToken.timestamp < this.CACHE_TTL_MS)) {\n        const token = cachedToken.token;\n        \n        // If the token is expired or about to expire, refresh it\n        if (this.isTokenExpiredOrExpiring(token)) {\n          console.log(`[OAuthTokenManager] Cached token for user ${userId} is expired or expiring soon. Refreshing...`);\n          return await this.refreshAndUpdateToken(userId, provider, token);\n        }\n        \n        // Token is valid, return it\n        return { token, refreshed: false };\n      }\n      \n      // No valid cache, get from database\n      console.log(`[OAuthTokenManager] Getting token for user ${userId} with provider ${provider}`);\n      const token = await this.getTokenFromDatabase(userId, provider);\n      \n      // If the token is expired or about to expire, refresh it\n      if (this.isTokenExpiredOrExpiring(token)) {\n        console.log(`[OAuthTokenManager] Token for user ${userId} is expired or expiring soon. Refreshing...`);\n        return await this.refreshAndUpdateToken(userId, provider, token);\n      }\n      \n      // Update cache with the token\n      this.tokenCache.set(cacheKey, { token, timestamp: Date.now() });\n      \n      return { token, refreshed: false };\n    } catch (error) {\n      // Re-throw OAuth errors\n      if (error instanceof OAuthError) {\n        throw error;\n      }\n      \n      // Wrap other errors\n      throw new OAuthError(`Error getting valid token: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Creates or updates a token in the database\n   */\n  public async saveToken(\n    userId: string,\n    provider: OAuthProvider,\n    tokenSet: OAuthTokenSet,\n    providerId?: string\n  ): Promise<OAuthTokenRecord> {\n    try {\n      console.log(`[OAuthTokenManager] Saving token for user ${userId} with provider ${provider}`);\n      \n      // Create token record\n      const tokenData: Record<string, unknown> = {\n        user_id: userId,\n        provider,\n        access_token: tokenSet.access_token,\n        refresh_token: tokenSet.refresh_token ?? null,\n        token_type: tokenSet.token_type ?? 'Bearer',\n        expires_at: tokenSet.expires_at ?? null,\n        scope: tokenSet.scope ?? null,\n        id_token: tokenSet.id_token ?? null,\n        updated_at: new Date().toISOString()\n      };\n      \n      // Add provider user ID if provided\n      if (providerId) {\n        tokenData.provider_user_id = providerId;\n      }\n      \n      // Start a Supabase transaction for atomicity\n      const { data: savedToken, error } = await supabaseAdmin\n        .from('oauth_connections')\n        .upsert(tokenData, { \n          onConflict: 'user_id,provider'\n        })\n        .select();\n      \n      if (error) {\n        throw new OAuthDatabaseError('token save', error);\n      }\n      \n      if (!savedToken || savedToken.length === 0) {\n        throw new OAuthDatabaseError('token save', new Error('No records returned after upsert'));\n      }\n      \n      // Sync to legacy table for backward compatibility\n      await this.syncToLegacyTable(userId, provider, tokenSet);\n      \n      // Cache the token\n      const token = savedToken[0] as OAuthTokenRecord;\n      this.tokenCache.set(`${userId}:${provider}`, { token, timestamp: Date.now() });\n      \n      return token;\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        throw error;\n      }\n      \n      throw new OAuthDatabaseError(\n        'token save', \n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n  \n  /**\n   * Removes a token for a user and provider\n   */\n  public async removeToken(userId: string, provider: OAuthProvider): Promise<void> {\n    try {\n      console.log(`[OAuthTokenManager] Removing token for user ${userId} with provider ${provider}`);\n      \n      // Remove the token from primary table\n      const { error: primaryError } = await supabaseAdmin\n        .from('oauth_connections')\n        .delete()\n        .eq('user_id', userId)\n        .eq('provider', provider);\n      \n      if (primaryError) {\n        throw new OAuthDatabaseError('token removal', primaryError);\n      }\n      \n      // Remove from legacy table as well\n      const { error: legacyError } = await supabaseAdmin\n        .from('user_oauth_tokens')\n        .delete()\n        .eq('user_id', userId)\n        .eq('provider', provider);\n      \n      if (legacyError) {\n        console.warn(`Warning: Could not remove token from legacy table: ${legacyError.message}`);\n      }\n      \n      // Remove from cache\n      this.tokenCache.delete(`${userId}:${provider}`);\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        throw error;\n      }\n      \n      throw new OAuthDatabaseError(\n        'token removal', \n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n  \n  /**\n   * Checks if the user has a valid token for the specified provider\n   */\n  public async hasValidToken(userId: string, provider: OAuthProvider): Promise<boolean> {\n    try {\n      await this.getValidToken(userId, provider);\n      return true;\n    } catch (error) {\n      // If we get a token not found or token expired error, return false\n      if (\n        error instanceof TokenNotFoundError ||\n        error instanceof TokenExpiredError ||\n        error instanceof TokenRefreshError\n      ) {\n        return false;\n      }\n      \n      // Otherwise, re-throw the error\n      throw error;\n    }\n  }\n  \n  /*********************\n   * Private Methods \n   *********************/\n  \n  /**\n   * Retrieves token from the database, checking both primary and legacy tables\n   */\n  private async getTokenFromDatabase(userId: string, provider: OAuthProvider): Promise<OAuthTokenRecord> {\n    // Check primary table first\n    const { data: primaryData, error: primaryError } = await supabaseAdmin\n      .from('oauth_connections')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('provider', provider)\n      .maybeSingle();\n    \n    if (primaryError && primaryError.code !== 'PGRST116') {\n      throw new OAuthDatabaseError('token retrieval', primaryError);\n    }\n    \n    if (primaryData) {\n      return primaryData as OAuthTokenRecord;\n    }\n    \n    // Check legacy table\n    const { data: legacyData, error: legacyError } = await supabaseAdmin\n      .from('user_oauth_tokens')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('provider', provider)\n      .maybeSingle();\n    \n    if (legacyError && legacyError.code !== 'PGRST116') {\n      throw new OAuthDatabaseError('token retrieval from legacy table', legacyError);\n    }\n    \n    if (legacyData) {\n      // Found in legacy table, migrate to primary table\n      const migratedToken = await this.migrateFromLegacyTable(legacyData, userId, provider);\n      return migratedToken;\n    }\n    \n    // Token not found in either table\n    throw new TokenNotFoundError(userId, provider);\n  }\n  \n  /**\n   * Refreshes token and updates in database\n   */\n  private async refreshAndUpdateToken(\n    userId: string, \n    provider: OAuthProvider, \n    token: OAuthTokenRecord\n  ): Promise<TokenResponse> {\n    // Verify we have a refresh token\n    if (!token.refresh_token) {\n      // Handle error gracefully\n      console.warn(`No refresh token available for user ${userId} with provider ${provider}`);\n      throw new TokenExpiredError(userId, provider);\n    }\n    \n    try {\n      // Refresh the token\n      const refreshResult = await this.refreshProviderToken(provider, token.refresh_token);\n      \n      // Create updated token set\n      const tokenSet: OAuthTokenSet = {\n        access_token: refreshResult.accessToken,\n        refresh_token: refreshResult.refreshToken || token.refresh_token,\n        expires_at: refreshResult.expiresAt,\n        scope: refreshResult.scope || token.scope,\n        id_token: token.id_token,\n        token_type: token.token_type || 'Bearer'\n      };\n      \n      // Save the refreshed token\n      const updatedToken = await this.saveToken(\n        userId, \n        provider, \n        tokenSet,\n        token.provider_user_id || undefined\n      );\n      \n      return { token: updatedToken, refreshed: true };\n    } catch (error) {\n      console.error(`Error refreshing token for user ${userId}:`, error);\n      \n      // If refresh failed, the token is likely invalid\n      // Remove the invalid token to force re-authorization\n      try {\n        await this.removeToken(userId, provider);\n      } catch (removeError) {\n        console.error(`Error removing invalid token:`, removeError);\n      }\n      \n      throw new TokenRefreshError(\n        userId, \n        provider, \n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n  \n  /**\n   * Provider-specific token refresh implementation\n   */\n  private async refreshProviderToken(\n    provider: OAuthProvider, \n    refreshToken: string\n  ): Promise<TokenRefreshResult> {\n    switch (provider) {\n      case 'google':\n        return await this.refreshGoogleToken(refreshToken);\n      default:\n        throw new Error(`Unsupported provider: ${provider}`);\n    }\n  }\n  \n  /**\n   * Refreshes a Google OAuth token\n   */\n  private async refreshGoogleToken(refreshToken: string): Promise<TokenRefreshResult> {\n    try {\n      // Get Google OAuth configuration\n      const config = oauthConfigService.getGoogleConfig();\n      \n      // Create OAuth client\n      const oauth2Client = new google.auth.OAuth2(\n        config.clientId,\n        config.clientSecret,\n        config.redirectUri\n      );\n      \n      // Set the refresh token\n      oauth2Client.setCredentials({ refresh_token: refreshToken });\n      \n      // Refresh the token\n      const { credentials } = await oauth2Client.refreshAccessToken();\n      \n      // Verify we got a new access token\n      if (!credentials.access_token) {\n        throw new Error('Google API did not return a new access token');\n      }\n      \n      return {\n        accessToken: credentials.access_token,\n        refreshToken: credentials.refresh_token || null,\n        expiresAt: credentials.expiry_date ? new Date(credentials.expiry_date).toISOString() : null,\n        scope: typeof credentials.scope === 'string' ? credentials.scope : null\n      };\n    } catch (error) {\n      throw new Error(`Failed to refresh Google token: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Migrates a token from the legacy table to the primary table\n   */\n  private async migrateFromLegacyTable(\n    legacyData: Record<string, unknown>, \n    userId: string, \n    provider: OAuthProvider\n  ): Promise<OAuthTokenRecord> {\n    try {\n      console.log(`[OAuthTokenManager] Migrating token from legacy table for user ${userId}`);\n      \n      // Convert legacy token to the new format\n      const tokenSet: OAuthTokenSet = {\n        access_token: legacyData.access_token as string,\n        refresh_token: (legacyData.refresh_token as string) || null,\n        expires_at: (legacyData.expires_at as string) || null,\n        scope: Array.isArray(legacyData.scopes) \n          ? (legacyData.scopes as string[]).join(' ') \n          : null,\n        token_type: 'Bearer'\n      };\n      \n      // Save to the primary table\n      return await this.saveToken(\n        userId, \n        provider, \n        tokenSet,\n        (legacyData.provider_user_id as string) || undefined\n      );\n    } catch (error) {\n      throw new OAuthDatabaseError(\n        'token migration', \n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n  \n  /**\n   * Syncs a token to the legacy table for backward compatibility\n   */\n  private async syncToLegacyTable(\n    userId: string, \n    provider: OAuthProvider, \n    tokenSet: OAuthTokenSet\n  ): Promise<void> {\n    try {\n      // Convert the scope string to array for the legacy table\n      const scopesArray = tokenSet.scope ? tokenSet.scope.split(' ') : null;\n      \n      const legacyRecord = {\n        user_id: userId,\n        provider,\n        access_token: tokenSet.access_token,\n        refresh_token: tokenSet.refresh_token || null,\n        expires_at: tokenSet.expires_at || null,\n        scopes: scopesArray,\n        updated_at: new Date().toISOString()\n      };\n      \n      const { error } = await supabaseAdmin\n        .from('user_oauth_tokens')\n        .upsert(legacyRecord, { \n          onConflict: 'user_id,provider'\n        });\n      \n      if (error) {\n        console.warn(`[OAuthTokenManager] Warning: Could not sync to legacy table: ${error.message}`);\n      }\n    } catch (error) {\n      // Log but don't throw - legacy table sync is best-effort\n      console.warn(`[OAuthTokenManager] Error syncing to legacy table: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Checks if a token is expired or will expire soon\n   */\n  private isTokenExpiredOrExpiring(token: OAuthTokenRecord): boolean {\n    if (!token.expires_at) {\n      return false; // If no expiry, assume it's valid\n    }\n    \n    const expiryTime = new Date(token.expires_at).getTime();\n    const now = Date.now();\n    \n    // Check if token is expired or will expire within the buffer time\n    return now + this.EXPIRY_BUFFER_MS >= expiryTime;\n  }\n}\n\n// Export singleton instance\nexport const oauthTokenManager = new OAuthTokenManager();"]}